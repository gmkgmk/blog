

# 一.react点击事件系统-js事件系统



**第一阶段首先简略的介绍js事件系统,主要是讲述个人觉得需要注意的点,不会完全讲api,可以直接查看第二阶段**

## 广义的Js与分类

*语言产生:javascript这门语言产生与上世纪90年代,这门语言产生是因为当时是拨号上网,带宽小,速度慢,如果提交表单的时候有一些不符合要求的信息提交到后台进行校验会产生浪费的和不必要的等待,所以产生了js这门语言*

发展初期，JavaScript的标准并未确定，同期有*网景的JavaScript*，*微软的JScript*和CEnvi的ScriptEase三足鼎立。1997年，在ECMA（欧洲计算机制造商协会）的协调下，由Netscape、Sun、微软、Borland组成的工作组确定统一标准：ECMA-262。

我们常说的js实际上是分为

1. ECMAScript (核心)
2. BOM　(文档对象模型)
3. DOM　(浏览器对象模型)

![image-20190724164423705](/Users/guo/Library/Application Support/typora-user-images/image-20190724164423705.png)

##

##一.DOM与DOM事件

到今天为止,dom已经产生了三个阶段的标准(**dom0并不算w3c标准**,但是dom0是兼容性最好的)



![image-20190724165556041](/Users/guo/Library/Application Support/typora-user-images/image-20190724165556041.png)

> 为什么会有dom0 级事件?
>
> 路由走的人多了自然就成了路!
>
> 首先出来了网景公司的Navigator浏览器和微软的IE浏览器，那时候还没有W3C规范，但是已经存在了一些DOM模型及相应的事件。所以这个在W3C规范产生之前的DOM模型就是DOM0。其中用到的比较老的事件也被放在DOM0中，但是不属于W3C指定的DOM规范。
>
> DOM 是 Netscape 最早提出，并且与 JS 的诞生是在同一个时间。Netscape2 浏览器首先实现了 DOM，定义了获取文档中一些元素的入口，比如 `document.forms` 和 `document.images`，后期的浏览器为了实现向后兼容，同样也支持这些接口。**在 JS 事件中，我们经常提及的 DOM 事件，也是在这个阶段定义的**。其它比较常用的还有 CSS 访问、DOM 遍历、等。。。

Dom0  函数直接绑定方法,形如:

```js
dom.onclick=fn()
```



Dom1 没有关于对事件进行详细的介绍

- DOM核心：针对任何结构化文档的标准模型
- DOM HTML：只针对HTML文档的标准模型

https://www.w3.org/TR/2000/WD-DOM-Level-1-20000929/



Dom2  现代常用的事件绑定方法

 ```js
dom.addEventListener(eventType,callBack,option)
 ```

需要注意的地方

1.分为冒泡和捕获事件;

2.addEventListener其实是一个队列

3.第三个参数常用的为**useCapture**,实际上可以为一个对象



![image-20190724171610646](/Users/guo/Library/Application Support/typora-user-images/image-20190724171610646.png)



更多详情参见https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener,



​	其中最需要注意的是passive这个api,平时在开发中很少看到有人使用,但是在使用react,vue过程中你会发现一个错误

> [Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive. See <URL>

这个问题其实就是passive解决禁止调用perventDefaul();
关于passive解决的痛点如下

> 当你触摸滑动页面时，页面应该跟随手指一起滚动。而此时你绑定了一个 `touchstart` 事件，你的事件大概执行 200 毫秒。这时浏览器就犯迷糊了：如果你在事件绑定函数中调用了 `preventDefault`，那么页面就不应该滚动，如果你没有调用 `preventDefault`，页面就需要滚动。但是你到底调用了还是没有调用，浏览器不知道。只能先执行你的函数，等 200 毫秒后，绑定事件执行完了，浏览器才知道，“哦，原来你没有阻止默认行为，好的，我马上滚”。此时，页面开始滚。

所以绑定事件的时候,passive能够提前告诉浏览器：“我不调用 `preventDefault` 函数来阻止事件事件行为”，那么浏览器就能快速生成事件，从而提升页面性能



Dom3 主要在于完善Dom,新增了一些事件,和**自定义事件**;



## 二.事件流

在dom2时,规定了事件流包含三个阶段:

1：事件捕获，
2：处于目标阶段，
3：事件冒泡阶段

具体如下

![image-20190724173428932](/Users/guo/Library/Application Support/typora-user-images/image-20190724173428932.png)

 那么为什么会有事件流呢?

由于微软和网景乱搞,后来必须要为事件传播机制,制定一个标准,因为事件捕获是网景公司开发出来的,而事件冒泡是由微软公司开发出来的,它们都想要自己的技术成为标准,所以导致这两个公司老是干架,制定标准的人为了不让它们干架,所以研发了事件流.



## 三.Event

> Event 接口表示在
> DOM 中发生的任何事件; 一些是用户生成的（例如鼠标或键盘事件），而其他由
> API 生成（例如指示动画已经完成运行的事件，视频已被暂停等等）。事件通常由外部源触发，同样也会以编程方式触发，例如执行一个 element 的一个 [HTMLElement.click( )](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/click) 方法，或通过定义事件，然后使用 [EventTarget.dispatchEvent( )](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent) 将其派发到一个指定的目标。有许多类型的事件，其中一些使用基于主要事件接口的其他接口。事件本身包含所有事件通用的属性和方法。



![image-20190724173828289](/Users/guo/Library/Application Support/typora-user-images/image-20190724173828289.png)

上图是evnet对象的详细信息,具体主要关注target,currentTarget;

**target**  触发这个事件的节点

**currentTarget** 添加绑定事件的节点

target和currentTarget为什么会不一样呢?因为事件委托的时候,会把节点绑定到父节点,避免了子节点多次绑定事件,通过父节点的事件来触发字节点需要触发的事件;

> 什么是事件委托?
>
> 这个概念依赖于这样一个事实,如果你想要在大量子元素中单击任何一个都可以运行一段代码，您可以将事件监听器设置在其父节点上，并将事件监听器气泡的影响设置为每个子节点，而不是每个子节点单独设置事件监听器。



*但是可以看到currentTarget为什么会是空的呢,但是直接打印event.currentTarget会有值呢?*

尤大大的一个回答解释了这个疑问 

![image-20190725164245114](/Users/guo/Library/Application Support/typora-user-images/image-20190725164245114.png)



currentTarget对象会在事件结束之后回收掉,由于log打印的是一个应用,所以当currentTarget打印出来以后对象指针已经消失,所以会出现log出来为空;



这就是react需要了解的基本js事件知识,简单总结一下几个大类;

1. dom2级事件(addEventListener)

2. 事件流(冒泡,捕获)

3. 事件委托

4. event对象(target,currentTarget)

   

