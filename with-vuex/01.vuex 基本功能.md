# vuex代码学习



Vuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。



vuex常用来和react的管理框架redux对比,从学习成本对比vuex的学习成本比redux低了很多,使用上和redux的dva很像,从学习源码上对比的话,vuex很简单就能学习,相比redux系列的函数式代码看着简单明了,(vue整个体系就是为了迎合开发者的开发习惯,使用了比较取巧的方法占领市场份额),可以先尝试掌握vuex的实现再去学习redux等的实现,由简至繁.



### 一.不考虑module的实现



### Install

通过mixin,在beforeCreate阶段初始化 

只在父组件上初始化,子组件获取使用父组件的$store.



### 初始化 

```js
  this._vm = new Vue({
      data: {
        $$state: state
      }
    });
```

在不考虑module的情况下面,最重要的就是需要new 一份 vue对象,对state进行数据劫持,所以vuex和vue一定是强耦合的,他实现的基础就是通过vue的数据劫持,



### state  用过拦截store的state 返回初始化时this._vm._data.$$state

这一步完成后就可以通过this.$store.state.xxx获取state的值.



### Getter  

通过劫持对象的对应名称,实行getter函数

```js
 const getters = options.getters || {};
    forEach(getters, (getter, getterName) => {
      Object.defineProperty(this.getters, getterName, {
        get: () => {
          return getter(this.state);
        }
      });
    });
```

将事件绑定在this.getters对象上,拦截对应的名称执行getter 函数.



### Mutation

绑定方式和getter类型,但是不需要劫持get方法,因为不需要在模版中直接获取,在this.mutations对象上绑定一个对应的方法,当触发的时候传入当前的state和传入的payload 

```js
 forEach(mutations, (mutation, mutationName) => {
      this.mutations[mutationName] = payload => {
        mutation.call(this, this.state, payload);
      };
    });
```



### Action action处理同上

处理方法和mutation一样.只是触发的时候传入的是当前对象和传入的payload.

### Commit Dispatch

只需要根据type取到对应的函数,传入payload执行即可.

```js
  commit = (type, payload) => {
    this.mutations[type](payload);
  };
  dispatch = (type, payload) => {
    this.actions[type](payload);
  };
```



这就是vuex的基本功能,基本可以理解vuex是如何运行的.

比较出彩的就是通过vue的双向绑定对state进行了接触,其他的基本就是一个整理过程,比较难的应该是分割模块.









