### 二.增加模块功能

上一步完成的只是基础功能,能够理解vuex数据是如何流动.

这一步主要是为了增加模块功能



###第一步: 转换成需要的格式

首先需要进行格式化,转换成一个树结构,如下

```js
const module = {
      _rawModule: rawModule,
      children: Object.create(null),
      state: rawModule.state || {}
    };
```

我们需要将所有的store 配置改编成需要的结构,一个典型的树结构.

在初始化的时候,首先进行结构转换,通过moduleCollection进行模块收集



```js
//Store
this._modules = new moduleCollection(options);

//moduleCollection
class moduleCollection {
  constructor(rawRootModule) {
    this.register([], rawRootModule);
  }
   register(path, rawModule) {}
}
```

可以看到是直接将option对象传入模块收集类

在初始化中调用了register方法,主要是传入的path,rawModule方法

path代表的是现在循环的路径,rawRootModule代表当前的模块

**一个深度优先遍历,最顶层的树顶path为空,每往下遍历一级,就会往里面加入一个节点名称**

path数组主要就是一个节点名称的收集.



接下来看一下register函数的实现

```js
 register(path, rawModule) {
    const module = {
      _rawModule: rawModule,
      children: Object.create(null),
      state: rawModule.state || {}
    };
    // 根目录
    if (path.length === 0) {
      this.root = module;
    } else {
      const parent = path.slice(0, -1).reduce((root, item) => {
        return root.children[item];
      }, this.root);
      parent.children[path[path.length - 1]] = module;
    }

    if (rawModule.modules) {
      forEach(rawModule.modules, (rawChildModule, key) => {
        this.register(path.concat(key), rawChildModule);
      });
    }
  }
```

先看最后对于rawModule.modules模块的处理,如果有modules则循环调用register方法进行遍历.

```js
 if (path.length === 0) {
      this.root = module;
    } 
```

如果path的长度为零,说明是树的入口,保留为根结点.

```js
//伪代码
/*
path ['order','user'] 
this.root = {
	children:{
		order:{
			children:{
				user
			}
		}
	}
}
*/

const parent = path.slice(0, -1).reduce((root, item) => {
        return root.children[item];
      }, this.root);
      parent.children[path[path.length - 1]] = module;
```

从根结点出发,循环path,获取当前的节点的上一层节点,然后将当前节点赋值给上一层节点的children属性上面.



### 第二步 递归格式好的数据

格式成我们需要的格式之后,肯定需要递归树结构,因为每个模块的state不一样,需要进行相应的修改,重新加载每个模块的数据.

```js
this._modules = new moduleCollection(options);
installModule(this, this._modules.root.state, [], this._modules.root);

function installModule(store, rootState, path, module) {}
```

需要传入store,根结点的state,树节点的path,当前循环的module



##### Children:首先看最简单的对与子节点的处理

```js
  // 递归子
  if (module.children) {
    forEach(module.children, (child, key) => {
      installModule(store, rootState, path.concat(key), child);
    });
  }
```

通过一个简单的递归,传入当前节点的path和当前节点

##### State: 通过vue的特性

```js
  if (path.length > 0) {
    const parent = path.slice(0, -1).reduce((root, current) => {
      return root.current;
    }, rootState);
    Vue.set(parent, path[path.length - 1], module.state);
  }
```

如果**非根结点**,获取上一层节点的*state*,通过**Vue.set**以当前的 path 为键,设置当前的state到**上一层节点的state上**

注意这里是对上一层state进行操作,这样才能通过this.$store.state.order.user.age 获取,吧下一层节点,当成上一层state的值.

**这里使用Vue.set**方法设置值,标志新加入的子节点也加入Vue的数据监听,这也是vue和Vuex强耦合的表现之一.

### Getter Mutation Action

这三个方法处理和之前大致相同,但是需要搞清楚现在递归的传入的每个值的作用,这里需要传入相应的module的state,mutation,action等,而不再是全局的state.

还有一个不同的地方是 Mutation Action可以是重名的的,所以需要改成数组来对应处理.

```js
function createActions(store, module) {
  const actions = module._rawModule.actions || [];
  forEach(actions, (action, actionName) => {
    let arr = store.actions[actionName] || (store.actions[actionName] = []);
    arr.push(payload => {
      // action传入的 是store对象
      action(store, payload);
    });
  });
}

function createMutation(store, module) {
  const mutations = module._rawModule.mutations || [];
  forEach(mutations, (mutation, mutationName) => {
    let arr =
      store.mutations[mutationName] || (store.mutations[mutationName] = []);
    arr.push(payload => {
      // mutation 传入的是对应module 的 state
      mutation(module.state, payload);
    });
  });
}

function createGetter(store, module) {
  const getters = module._rawModule.getters;
  if (getters) {
    forEach(getters, (getter, getterName) => {
      // 不重复注册
      if (store.getters[getterName]) {
        return;
      }
      Object.defineProperty(store.getters, getterName, {
        get: () => {
          // 传入对应module state
          return getter(module.state);
        }
      });
    });
  }
}
```

### commit dispath

mutation 和 action修改用数组储存后,需要对应的循环数组执行.



到此,一个基本的vuex就已经实现了,但是还有一些细节需要处理,比如nameSpace, helpers, plugins等等细枝末节的地方,最重要的还是模块这一块.总结一下也就两步

### 1.格式化成需要的结构

### 2.递归数据,将对应的数据绑定在对象上











